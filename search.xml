<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【面试前传】JS中的一些小问题（一）]]></title>
    <url>%2F2019%2F04%2F15%2F%E3%80%90%E9%9D%A2%E8%AF%95%E5%89%8D%E4%BC%A0%E3%80%91JS%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本节概要1，原始类型与对象类型2，typeof和instanceof的原理与区别 一、原始类型学过ES6的小伙伴们都知道，原始类型呢，主要分为六种分别是 Boolean,Null,Undefined,Number,String,Symbol 当然，这些类型的详细概念就不用我多做解释啦，只不过，小宏同学在学习时对Symbol不是特别理解，多亏大佬的帮忙，小伙伴们若想对Symbol了解的更详细的话，不妨参考一下如下文章，或许会有所帮助。 ES6的原始类型数据——Symbol 接下来我们就说说这里的小问题 1，首先嘛，NULL不是对象，但是细心的小伙伴们会发现当你打印typeof null的值的时候，返回的却是Object？？这是为什么呢？ 通过查阅资料发现,其实这是 JS 存在的一个很久很久的Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。小宏觉得可能是留作纪念用的。。 2，JS的Number是浮点型，小宏同学在使用的时候就遇到了一些bug 10.1 + 0.2 !== 0.3 //true 小宏对这个结果也是不怎么太明白，后面研究透了我会做出补充。 3，原始类型存储的都是值，是没有函数阔以调用的比如说，undefined.toString() ####二、对象类型 当然啦，在JS中，除了原始类型，那就是对象类型了。在这里呢，小宏对对象类型也不做详细说明。只想说一下原始类型与对象类型有啥子不同，其实，简单的说，原始类型存储的是值，而对象类型存储的是地址（指针）。 比如下列代码123const a = []const b = ab.push(1) 细心的小伙伴会发现，代码运行后两个变量的值都发生了改变 我们可以这样看，对于常量 a ，我们假设内存地址为 #xiaohong，那么在地址 #xiaohong 的位置存放了值 []，常量 a 存放了地址#xiaohong，当我们将变量赋值给另外一个变量时，复制的是原本变量的地址，也就是说当前变量 b 存放的地址也是 #xiaohong，当我们进行数据修改的时候，就会修改存放在地址 #xiaohong 上的值，也就导致了两个变量的值都发生了改变。 ####三、typeof和instanceof 相信大家对这两者是在熟悉不过了，那小宏就做一个简单的总结就好了 1，typeof除了null都可以正确判断（原始类型）；除了函数都会显示object（对象类型）。也就是说，typeof其实是不能准确判断的。 2，instanceof主要用于对象的判断，当其用于原始类型的判断时，并不能返回正确的结果，（听大佬说可以通过Symbol.hasInstance来对instanceof行为进行重定义。小宏也不太懂，麻烦大佬在评论区进行解释，蟹蟹）。 好啦，今天的内容就先到这里，还希望大佬们多多支持。Fighting！]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
